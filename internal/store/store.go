package store

import (
	"context"

	"go-api-structure/internal/store/db"

	"github.com/google/uuid"
)

// Store defines the interface for all data store operations.
// It embeds the Querier interface generated by sqlc, which provides
// the low-level database access methods.
// Application-specific store interfaces (UserStore, VendorStore, MerchantStore)
// will be defined here and will typically use methods from the embedded Querier.
// This approach allows for a clean separation: sqlc handles raw DB interaction,
// while this package provides a more abstracted, application-aware data access layer.
type Store interface {
	db.Querier
	// We can add methods here that might combine multiple Querier calls
	// or perform operations not directly mapped to a single SQL query.
	// For now, embedding Querier is sufficient for basic CRUD, but this
	// provides a place for more complex transaction scripts or business logic
	// related to data access if needed in the future.
}

// UserStore defines the interface for user-specific data operations.
// It will typically be implemented by a struct that has access to a *db.Queries object.
// For now, we'll list methods that correspond to our sqlc queries for users.
// We'll also need to consider how parameters are passed (e.g., DTOs vs. direct model types).
type UserStore interface {
	CreateUser(ctx context.Context, arg db.CreateUserParams) (db.User, error)
	GetUserByID(ctx context.Context, id uuid.UUID) (db.User, error)
	GetUserByEmail(ctx context.Context, email string) (db.User, error)
	GetUserByUsername(ctx context.Context, username string) (db.User, error)
	// TODO: Add UpdateUser, DeleteUser if needed later
}

// VendorStore defines the interface for vendor-specific data operations.
type VendorStore interface {
	CreateVendor(ctx context.Context, arg db.CreateVendorParams) (db.Vendor, error)
	GetVendorByID(ctx context.Context, id uuid.UUID) (db.Vendor, error)
	ListVendorsByUserID(ctx context.Context, userID uuid.UUID) ([]db.Vendor, error)
	UpdateVendor(ctx context.Context, arg db.UpdateVendorParams) (db.Vendor, error)
	DeleteVendor(ctx context.Context, arg db.DeleteVendorParams) error
}

// MerchantStore defines the interface for merchant-specific data operations.
type MerchantStore interface {
	CreateMerchant(ctx context.Context, arg db.CreateMerchantParams) (db.Merchant, error)
	GetMerchantByID(ctx context.Context, id uuid.UUID) (db.Merchant, error)
	ListMerchantsByUserID(ctx context.Context, userID uuid.UUID) ([]db.Merchant, error)
	UpdateMerchant(ctx context.Context, arg db.UpdateMerchantParams) (db.Merchant, error)
	DeleteMerchant(ctx context.Context, arg db.DeleteMerchantParams) error
}

// SQLStore provides a concrete implementation of the Store interface using a *sql.DB connection pool.
// It holds a *db.Queries object, which is generated by sqlc.
// This struct will be the receiver for methods that implement UserStore, VendorStore, and MerchantStore.
type SQLStore struct {
	*db.Queries
	// db *sql.DB // The database connection pool, needed for transactions if not handled by sqlc's Querier directly.
	             // For now, *db.Queries takes a db.DBTX, which can be *sql.DB or *sql.Tx.
}

// NewStore creates a new SQLStore.
func NewStore(dbTX db.DBTX) Store {
	return &SQLStore{
		Queries: db.New(dbTX),
		// db: // if we were managing transactions manually here
	}
}

// UserStore implementation

func (s *SQLStore) CreateUser(ctx context.Context, arg db.CreateUserParams) (db.User, error) {
	return s.Queries.CreateUser(ctx, arg)
}

func (s *SQLStore) GetUserByID(ctx context.Context, id uuid.UUID) (db.User, error) {
	return s.Queries.GetUserByID(ctx, id)
}

func (s *SQLStore) GetUserByEmail(ctx context.Context, email string) (db.User, error) {
	return s.Queries.GetUserByEmail(ctx, email)
}

func (s *SQLStore) GetUserByUsername(ctx context.Context, username string) (db.User, error) {
	return s.Queries.GetUserByUsername(ctx, username)
}

// VendorStore implementation

func (s *SQLStore) CreateVendor(ctx context.Context, arg db.CreateVendorParams) (db.Vendor, error) {
	return s.Queries.CreateVendor(ctx, arg)
}

func (s *SQLStore) GetVendorByID(ctx context.Context, id uuid.UUID) (db.Vendor, error) {
	return s.Queries.GetVendorByID(ctx, id)
}

func (s *SQLStore) ListVendorsByUserID(ctx context.Context, userID uuid.UUID) ([]db.Vendor, error) {
	return s.Queries.ListVendorsByUserID(ctx, userID)
}

func (s *SQLStore) UpdateVendor(ctx context.Context, arg db.UpdateVendorParams) (db.Vendor, error) {
	return s.Queries.UpdateVendor(ctx, arg)
}

func (s *SQLStore) DeleteVendor(ctx context.Context, arg db.DeleteVendorParams) error {
	return s.Queries.DeleteVendor(ctx, arg)
}

// MerchantStore implementation

func (s *SQLStore) CreateMerchant(ctx context.Context, arg db.CreateMerchantParams) (db.Merchant, error) {
	return s.Queries.CreateMerchant(ctx, arg)
}

func (s *SQLStore) GetMerchantByID(ctx context.Context, id uuid.UUID) (db.Merchant, error) {
	return s.Queries.GetMerchantByID(ctx, id)
}

func (s *SQLStore) ListMerchantsByUserID(ctx context.Context, userID uuid.UUID) ([]db.Merchant, error) {
	return s.Queries.ListMerchantsByUserID(ctx, userID)
}

func (s *SQLStore) UpdateMerchant(ctx context.Context, arg db.UpdateMerchantParams) (db.Merchant, error) {
	return s.Queries.UpdateMerchant(ctx, arg)
}

func (s *SQLStore) DeleteMerchant(ctx context.Context, arg db.DeleteMerchantParams) error {
	return s.Queries.DeleteMerchant(ctx, arg)
}
