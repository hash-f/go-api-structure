package store

import (
	"context"
	"errors"

	"go-api-structure/internal/store/db"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

// Store defines the interface for all data store operations.
// It embeds the Querier interface generated by sqlc, which provides
// the low-level database access methods.
// Application-specific store interfaces (UserStore, VendorStore, MerchantStore)
// will be defined here and will typically use methods from the embedded Querier.
// This approach allows for a clean separation: sqlc handles raw DB interaction,
// while this package provides a more abstracted, application-aware data access layer.

var (
	// ErrNotFound is returned when a specific resource is not found in the store.
	ErrNotFound = errors.New("store: resource not found")
)

type Store interface {
	db.Querier
	// We can add methods here that might combine multiple Querier calls
	// or perform operations not directly mapped to a single SQL query.
	// For now, embedding Querier is sufficient for basic CRUD, but this
	// provides a place for more complex transaction scripts or business logic
	// related to data access if needed in the future.
}

// UserStore defines the interface for user-specific data operations.
// It will typically be implemented by a struct that has access to a *db.Queries object.
// For now, we'll list methods that correspond to our sqlc queries for users.
// We'll also need to consider how parameters are passed (e.g., DTOs vs. direct model types).
type UserStore interface {
	CreateUser(ctx context.Context, arg db.CreateUserParams) (db.User, error)
	GetUserByID(ctx context.Context, id uuid.UUID) (db.User, error)
	GetUserByEmail(ctx context.Context, email string) (db.User, error)
	GetUserByUsername(ctx context.Context, username string) (db.User, error)
	GetUserByAPIKey(ctx context.Context, apiKey string) (db.User, error)
	// TODO: Add UpdateUser, DeleteUser if needed later
}

// SQLStore provides a concrete implementation of the Store interface using a *sql.DB connection pool.
// It holds a *db.Queries object, which is generated by sqlc.
// This struct will be the receiver for methods that implement UserStore, VendorStore, and MerchantStore.
type SQLStore struct {
	*db.Queries
	// db *sql.DB // The database connection pool, needed for transactions if not handled by sqlc's Querier directly.
	// For now, *db.Queries takes a db.DBTX, which can be *sql.DB or *sql.Tx.
}

// NewStore creates a new SQLStore.
func NewStore(dbTX db.DBTX) Store {
	return &SQLStore{
		Queries: db.New(dbTX),
		// db: // if we were managing transactions manually here
	}
}

// UserStore implementation

func (s *SQLStore) CreateUser(ctx context.Context, arg db.CreateUserParams) (db.User, error) {
	return s.Queries.CreateUser(ctx, arg)
}

func (s *SQLStore) GetUserByID(ctx context.Context, id uuid.UUID) (db.User, error) {
	user, err := s.Queries.GetUserByID(ctx, id)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return db.User{}, ErrNotFound
		}
		return db.User{}, err
	}
	return user, nil
}

func (s *SQLStore) GetUserByEmail(ctx context.Context, email string) (db.User, error) {
	user, err := s.Queries.GetUserByEmail(ctx, email)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return db.User{}, ErrNotFound
		}
		return db.User{}, err
	}
	return user, nil
}

func (s *SQLStore) GetUserByUsername(ctx context.Context, username string) (db.User, error) {
	user, err := s.Queries.GetUserByUsername(ctx, username)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return db.User{}, ErrNotFound
		}
		return db.User{}, err
	}
	return user, nil
}

func (s *SQLStore) GetUserByAPIKey(ctx context.Context, apiKey string) (db.User, error) {
	user, err := s.Queries.GetUserByAPIKey(ctx, apiKey)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return db.User{}, ErrNotFound
		}
		return db.User{}, err
	}
	return user, nil
}
